package dip;

/*
0. Принцип инверсии зависимостей [#4917]
В этом уроке речь пойдет о принципе DIP (Dependency Inversion Principle) - принцип инверсии зависимостей.

Данный принцип гласит:
Модули верхнего уровня не должны зависеть от модулей
нижнего уровня. И те и другие должны зависеть от абстракций.

Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

Проще говоря, используемые сущности в вашем
коде должны быть абстракциями, т.е. не должно
быть прямой зависимости от реализации.

Это касается:

- полей классов
- возвращаемых значений методов
- аргументов методов и конструкторов
- создаваемых объектов (вспомните пример из урока про SRP)

Чаще всего это не касается моделей
данных бизнес-логики, т.е. классов типа Item,
Post, User, Role и т.д, однако если они также содержат
какую-то логику, то правило также действует и на них.

Рассмотрим такой пример. Пусть нам нужно написать
сервис простого интернет магазина:
У нас есть базовая сущность:

public abstract class BaseEntity
и такие модели:
public class User extends BaseEntity
public class Product extends BaseEntity
public class Order
и есть сам класс сервис:
SimpleShopService

На что стоит обратить внимание?
1. Поля. У сервиса есть единственное поле - мапа,
для хранения данных. С точки зрения DIP, это нарушение,
потому что мы зависим от реализации, а не абстракции.
Решение - выделение абстракции для хранилища и уже
далее от него нужно будет реализовать InMemoryShopStore
-
public interface ShopStore {

    boolean saveUser(User user);
    boolean saveOrder(User user, Order order);
    Set<Order> getOrders(User user);
    Set<User> getUsers();
}
-
и в самом сервисе избавиться от зависимости
на само хранилище. Тогда можно будет его подменить
на любое другое, т.к. нет прямой зависимости.
private ShopStore shopStore;

public SimpleShopService(ShopStore shopStore) {
    this.shopStore = shopStore;
}
-
2. Стоит обратить внимание на подобные строки.
Вы уже знакомы с логгированием, которое проходили
в разделе IO. Подобная запись также является
нарушением DIP, потому что есть прямая зависимость
самого логгирования от реализации, в данном случае
оно напрямую зависит от консольного вывода.

System.out.println("Get error with "  + user + " " + order);

Решение опять использование абстракции для логирования
private static final Logger LOGGER = Logger.getLogger("Shop logger");

3. На входные параметры. В данном случае на Order.
Во-первых, этот класс нарушает SPR, потому что представляет
как саму модель заказа так и АПИ для работы с ней.
Во-вторых, он нарушает DIP, потому что опять же
сохранения идет в память, нам нужно здесь аналогично
абстрагироваться от самого хранилища, создав для
него отдельный интерфейс. Но зависимость от хранилища
уже будет в сервис заказа, а сервис магазина будет зависеть
от сервиса заказов

--
public class SimpleOrderService implements OrderService {
    private OrderStore orderStore;

    public SimpleOrderStore(OrderStore orderStore) {
        this.orderStore = orderStore;
    }
}

// уже в классе ShopService
--
private OrderService orderService;

public SimpleShopService(ShopStore shopStore, OrderService orderService) {
    this.shopStore = shopStore;
    this.orderService = orderService;
--

Вывод:
Как уже было сказано ранее, чтобы не нарушить принцип DIP
1. Выделяйте абстракции и делайте зависимости именно от них,
а не от их реализаций.
2. Для этого обращайте внимание на:
- поля классов
- возвращаемые значения методов
- аргументы методов и конструкторов
- создаваемые объекты
 */