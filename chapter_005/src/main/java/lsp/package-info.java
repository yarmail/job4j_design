package lsp;

/*
Общая часть
В этом уроке поговорим про LSP (Liskov Substitution Principle).
Данный принцип гласит, что если в коде используется
сущность X, то при постановке его наследников или
других реализаций Y код будет работать. Фактически этот принцип
гарантирует, что не нарушиться принцип OCP относительно
взаимосвязи между классами в иерархии.

Как проверить что ваш код не нарушает этот принцип?
Легко, представляете что нужно будет использовать
в коде какие-то специфические реализации и пытаетесь мы мысленно
их подставить. Если нет проблем с подстановкой, то все отлично.
В целом не должно быть завязки на конкретной реализации.

Контракты LSP

Контракт - это некое правило, соблюдение которого гарантирует,
что принцип не будет нарушен.
Применительно LSP выделяют следующие контракты:
1. Предусловия (Preconditions) не могут быть усилены в подклассе
Предусловие - это условие, которое проверяет корректность
аргументов конструктора или метода.

Допустим у нас есть класс автотранспорта.

public class AutoTransport
(пакет lsp auto)

Пусть теперь есть наследник - автобус.

class Bus extends AutoTransport

Предположим ему нужно больше топлива,
чтобы сдвинуться с места
От AutoTransport мы ожидаем, что машина сдвинется,
но нет. Автобус не сдвигается, т.к. в нем
усилино предусловие. Ожидаем мы одно поведение,
а получаем другое.
Чтобы сдвинуть автобус нам придеться
дописать доп. условие, чтобы проверить
является ли траспорт автобусом.
Далее уже скормить ему больше топлива.

Проверка запуска - FirstRule

---

2. Постусловия (Postconditions)
не могут быть ослаблены в подклассе.

Постусловие - это условие, налагаемое
на возвращаемое значение метода.

Рассмотрим такой пример.
Пусть есть бухгатерия, которая считает по табелю
сколько работник отработал и если он отработал норму,
то высчитывает для него зарплату.

(пакет lsp count)
class CountingRoom
class WorkDays implements Iterable<Integer>

Далее мы наследуемся допустим для бугалтерии магазина.

ShopCountingRoom

В нем мы забываем про условие когда добавляем
специфическое поведение
и когда запускаем пример, то получаем,
что недобросовестный работник получает зарплату.

Запускной проверочный класс SecondRule

----
ВНИМАНИЕ
Правила 1-2 не распространяются на приватные поля,
т.е. когда вы проверяете специфичные только для объекта поля,
то вы не нарушаете эти правила. Принцип Лисков контролирует
отношения между классами при наследовании.
---

3.
3. Инварианты (Invariants) — все условия базового класса
- также должны быть сохранены и в подклассе
Инвариант - это условие, которое постоянно на протяжении существования объекта.

Например, есть номер телефона.
(пакет lspphone)
PhoneNumber

Есть абонент.
class Subscriber

От него наследуется абонент какого-то оператора.
SomeOperatorSubscriber
Но при переопределении сеттера, забыли сделать проверку.
Поэтому код в майвине запускается успешно.
Ошибка остается. Нарушено состояние объекта потомка,
потому что в нем не соблюдено условие предка.

Также надо изучить Признаки нарушения принципа
 */
