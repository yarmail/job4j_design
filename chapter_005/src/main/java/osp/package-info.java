package osp;

/*
OCP – Open Closed Principle
0. Принцип открытости закрытости [#4914]
Данный принцип гласит, что программные
сущности должны быть открыты к расширению,
но закрыты к изменению.

!!!
Если говорить кратко, взаимодействие должно быть
строго через абстракции (интерфейсы, абстрактные классы),
за исключением примитивных типов и не изменяемых типов
(строки, классы-обертки, в общем классы помеченные final),
которые в конечном счете представляют собой состояние объектов.

Давайте сначала разберемся с тем,
что значит «расширить», а что значит «изменить».
Взгляните на пример кода ниже:

public class CalculatorExample

Допустим мне нужно будет добавить операцию вычитания
в программу. Для первого класса мне нужно будет
добавить еще метод, т.е. его изменить. Для второго
достаточно будет передать новую лямбду,
т.е. расширить программу, не изменяя ее.

Почему так важен факт изменения?
1) Изменение программы может привести к ее
некорректной работе. Если программа маленькая,
то продебажить ее не трудно, но если в ней много кода,
то это будет сделать затруднительно, поэтому
становится актуальным ее расширение, а не изменение.
2) Программы со временем меняются. Меняются требования.
Выходят новые версии. Все это делается за счет
возможности гибкого расширения программы.

Контекст расширения
Говоря о расширении важно отметить контекст,
в котором мы говорим о нем. В примере выше мы говорим
об отдельно взятом внутреннем классе, а именно о
внутреннем устройстве этих классов.

К примеру, кто-то может сказать: первый класс мы
можем тоже расширить, например через наследование.
Но тут уже другой контекст – контекст,
в котором будет применяться сам класс.
А это уже совсем другое. Не путайте контекст.

Таким образом при написании расширяемых классов
стоит обращать внимание:
- НА СОЗДАВАЕМЫЕ ОБЪЕКТЫ.
Помните классы должны зависеть от абстракций,
а не от реализаций (принцип DIP).
Вспомните пример из прошлого задания.
Подобный подход мешает наследованию.

- НА ПОЛЯ. Поля также должны представлять тип абстракций. Т
акой вариант тоже может привести к сложностям расширения,
т.к. чтобы расширить программу придется наследоваться,
но всегда наследование возможно.

- НА ПАРАМЕТРЫ И ВОЗВРАЩАЕМЫЕ ТИПЫ МЕТОДЫ.
Они тоже должны быть абстракциями.

!!!
Если говорить кратко, взаимодействие должно быть
строго через абстракции (интерфейсы, абстрактные классы),
за исключением примитивных типов и не изменяемых типов
(строки, классы-обертки, в общем классы помеченные final),
которые в конечном счете представляют собой состояние объектов.

Механизмы расширения
Расширение как правило достигается созданием новых сущностей.
Тут мы ярко можем увидеть полиморфизм.
Таким образом, расширение достигается за счет полиморфизма.
А за счет чего достигается полиморфизм?

Наследование
Пусть изначально был написан такой код

public class CarsInheritanceA

Теперь поступило требование, что некоторые машины не издают звука.
Как этот код можно расширить, реализуя требование?
Можно расширить за счет наследования,
создав новую сущность и добавив ее в список.

---

Интерфейсы и их реализация

Пусть изначально был написан такой код

public class FiguresImplemetation

Теперь поступило требование рисовать круги.
Можно ли здесь использовать наследование? Нет.
Т.к. при наследовании, наследуется состояние объекта предка.
Круг не может иметь те же характеристики,
что и прямоугольник, потому что круг
«не является» прямоугольником (отношение «is A» наследование),
но они оба могут быть отрисованы.
Таким образом исходный код изначально спроектирован неверно.
Нужно было сделать так:

FiguresImplemetationB

ВЫВОД
Наследование можно использовать только
при устойчивой иерархии классов, всегда
подставляйте «is A» между сущностями, чтобы проверить
можно ли наследоваться. Если не уверены, то лучше использовать
интерфейсы, потому что они дают гибкость. Также помните, что
при наследовании наследуется состояние объектов,
что не всегда удобно, нужно и допустимо.







*/